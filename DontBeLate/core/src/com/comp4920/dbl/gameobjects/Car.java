package com.comp4920.dbl.gameobjects;

import java.util.Collections;
import java.util.List;
import java.util.Random;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.comp4920.dbl.helpers.AssetLoader;
import com.comp4920.dbl.helpers.LaneHandler;

public class Car implements Obstacle{

	public static final int MAX_CAR_SPEED = 250;
	public static final int MIN_CAR_SPEED = 150;

	protected Vector2 position;
	protected Vector2 velocity;
	protected Vector2 acceleration;

	private Animation carAnimation;
	
	protected Rectangle boundingRectangle;
	
	public static final int WIDTH = 40;
	public static final int HEIGHT = 80;
	
	protected static final int CAR_WIDTH = 40;
	protected static final int CAR_HEIGHT = 80;	

	protected static boolean randomStartSpeed = true;
	private boolean stopped;
	private int maxSpeed;
	private int minSpeed;
	int defaultSpeed = 100;	//used if randomStartSpeed = false
	
	// used for merging
	private int laneID;
	private boolean merging;
	private Vector2 target;
	private Lane targetLane;

	
	// does not take an x or y coord
	// x is generated by getRandomX
	// y is the same every time
	public Car() {
		stopped = false;
        maxSpeed = MAX_CAR_SPEED;
        minSpeed = MIN_CAR_SPEED;
		int x = 10;
		int y = -CAR_HEIGHT;
		this.position = new Vector2(x, y);
		velocity = new Vector2(0, 20);
        acceleration = new Vector2(0, 100);
        velocity.y = genStartSpeed();
        boundingRectangle = new Rectangle();
        carAnimation = AssetLoader.carAnimation;
        laneID = -1;
	}
	
	//generates a car with a maximum speed
	public Car(int x_position, int maxSpeed, int laneID) {
        minSpeed = MIN_CAR_SPEED;
        this.maxSpeed = maxSpeed;
		int x = x_position;
		int y = -CAR_HEIGHT;
		this.position = new Vector2(x, y);
		velocity = new Vector2(0, 20);
        acceleration = new Vector2(0, 100);
        velocity.y = genStartSpeed();
        boundingRectangle = new Rectangle();
        carAnimation = AssetLoader.carAnimation;
        this.laneID = laneID;
        this.merging = false;
        this.target = null;
    	targetLane = null;
	}
	
	
	
	public void update(float delta) {
		if(!stopped){
			if (merging) {
				updateMerge(delta);
			} else {
				position.y += delta*(velocity.y + (Road.getRoadSpeed()-Road.DEFAULT_SPEED));
				boundingRectangle.set(position.x, position.y, CAR_WIDTH, CAR_HEIGHT);
			}
		}
	}
	

	private void updateMerge(float delta) {
		position.add(velocity.x*2, velocity.y);
		boundingRectangle.set(position.x, position.y, CAR_WIDTH, CAR_HEIGHT);
		if (completedMerge()){
			this.merging = false;
			velocity.set(0,100);
			laneID = (int) ((position.x/60) -1);
			//System.out.println("Ended in lane " + laneID);
		}
	}
	
	// returns a random starting x-coord
	//TODO: 'assign' columns to cars so they never overlap - maybe 'lanes'?
	// Cars do not generate own starting position anymore. Determined by which lane it belongs to.
	public int getStartX() {
		//Random rand = new Random();
		//int randomX = rand.nextInt((max - min) + 1) + min;
		//TODO: How to use this unused method?
		return 10;
	}
	
	
	public int genStartSpeed() {
		int speed = defaultSpeed;
		if (randomStartSpeed) {
			Random rand = new Random();
			speed = rand.nextInt((maxSpeed - minSpeed) + 1) + minSpeed;
		}
		return speed;
	}
	
	// Returns true if the coords of the car are offscreen.
	public boolean offScreen() {
		int screenHeight = Gdx.graphics.getHeight();
		return (this.getY()-CAR_HEIGHT/2 > screenHeight/2);
	}
	
	
	public void stop() {
		stopped = true;
	}

		
    public float getX() {
        return position.x;
    }

    public float getY() {
        return position.y;
    }

    public float getWidth() {
        return CAR_WIDTH;
    }

    public float getHeight() {
        return CAR_HEIGHT;
    }

    public Rectangle getHitBox() {
    	return boundingRectangle;
    }
    
    public float getVerticalSpeed(){
    	return velocity.y;
    }

    public Animation getAnimation() {
    	return carAnimation;
    }
    
    // TODO: check for potential collisions
    public boolean canMerge() {
    	return inMergeZone() && !merging && LaneHandler.canMerge();
    }
    
    // cars shouldnt start merging at the bottom of the screen or at the top
    public boolean inMergeZone() {
    	return (position.y>50 && position.y<120);
    }
    
    public void merge() {
    	target = acquireMergeTarget();
    	this.merging = true;
    	velocity.set(target.x-position.x, target.y-position.y);
    	velocity.nor();
    }
    
    
	private Vector2 acquireMergeTarget() {
    	while (targetLane == null) {
    		// get the lanes and shuffle the list
    		List<Lane> lanes = new LaneHandler().getLanes(); 
			long seed = System.nanoTime();
			Collections.shuffle(lanes, new Random(seed));

	    	for (Lane lane : lanes) {
	    		if (lane.getXPosition() != position.x && Math.abs(position.x - lane.getXPosition()) < 60) {
	    			targetLane = lane;
	    			//System.out.println("Moving from lane " + laneID);
	    		}
	    	}
    	}
    	return new Vector2(targetLane.getXPosition(), position.y+175);
    }
    
	//TODO: sometimes cars merge two lanes at once...
	private boolean completedMerge() {
		return Math.abs(position.x - target.x)<2;
	}
	
	public Lane getTargetLane() {
		return targetLane;
	}
    	
    public boolean merging() {
    	return merging;
    }
    
}
